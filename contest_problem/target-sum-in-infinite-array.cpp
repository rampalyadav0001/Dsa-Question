https://leetcode.com/problems/minimum-size-subarray-in-infinite-array/description/

 Minimum Size Subarray in Infinite Array

You are given a 0-indexed array nums and an integer target.

A 0-indexed array infinite_nums is generated by infinitely appending the elements of nums to itself.

Return the length of the shortest subarray of the array infinite_nums with a sum equal to target. If there is no such subarray return -1.

 

Example 1:

Input: nums = [1,2,3], target = 5
Output: 2
Explanation: In this example infinite_nums = [1,2,3,1,2,3,1,2,...].
The subarray in the range [1,2], has the sum equal to target = 5 and length = 2.
It can be proven that 2 is the shortest length of a subarray with sum equal to target = 5.
Example 2:

Input: nums = [1,1,1,2,3], target = 4
Output: 2
Explanation: In this example infinite_nums = [1,1,1,2,3,1,1,1,2,3,1,1,...].
The subarray in the range [4,5], has the sum equal to target = 4 and length = 2.
It can be proven that 2 is the shortest length of a subarray with sum equal to target = 4.
Example 3:

Input: nums = [2,4,6,8], target = 3
Output: -1
Explanation: In this example infinite_nums = [2,4,6,8,2,4,6,8,...].
It can be proven that there is no subarray with sum equal to target = 3.



code::->
At first, calculate the total sum of the array
If the target value is larger than the total sum of the array, we may need to repeat it one or more times.
initialize count variable to store how many times the total sum can fit into the target.

explanation::-->
Suppose we have an array nums = [1, 2, 3] and the target sum is target = 14.

First, we calculate the total sum of the array, which is totalSum = 1 + 2 + 3 = 6.
Then we check if the target is greater than the total sum. In this case, 14 > 6, so we enter the if block.
Inside the if block, we calculate how many times we need to repeat the entire array to reach the target. We do this by dividing the target by the total sum and multiplying by the size of the array (n). So, count = (14 / 6) * 3 = 2 * 3 = 6. This means we need to repeat the entire array twice (6 elements in total) to get close to the target.
Next, we calculate the remaining target after subtracting the multiples of the total sum. This is done using the modulus operator (%). So, target = 14 % 6 = 2. This means that after repeating the entire array twice, we still need to find a subarray in nums that sums up to 2 to reach the original target of 14.
So, in this example, we would repeat the array twice and then look for a subarray that sums up to 2. The length of this subarray plus the count (6 in this case) would be our final answer.


we use sliding window to find targetsum::-->
class Solution {
public:
    int minSizeSubarray(vector<int>& nums, int target) {
        int n = nums.size();
        long long totalsum = 0;  // Initialize a variable to store the total sum of elements in the 'nums' array.
        int count = 0;           // Initialize a variable to count the number of times the 'nums' array is repeated.

        // Calculate the total sum of elements in the 'nums' array.
        for (auto it : nums)
            totalsum += it;

        // If the total sum is less than the target, calculate the number of times the 'nums' array needs to be repeated to reach or exceed the target.
        if (totalsum < target) {
            count = (target / totalsum) * n;  // Calculate the number of times to repeat 'nums' to reach or exceed the target.
            target = target % totalsum;       // Calculate the remaining target after repeating 'nums'.
        }

        int right = 0, left = 0;  // Initialize two pointers for the sliding window approach.
        int sum = 0;             // Initialize a variable to store the current sum of elements in the window.
        bool ans = false;        // Initialize a flag to check if a valid subarray is found.
        int mini = INT_MAX;      // Initialize a variable to store the minimum subarray length.

        // Iterate through the 'nums' array using a sliding window.
        while (right < 2 * n) {
            sum += nums[right % n];  // Add the current element to the window sum.

            // Shrink the window from the left if the sum exceeds the target.
            while (left <= right && sum > target) {
                sum -= nums[left % n];
                left++;
            }

            // Check if the current window sum equals the target.
            if (sum == target) {
                ans = true;  // Set the flag to true, indicating a valid subarray is found.
                mini = min(mini, right - left + 1);  // Update the minimum subarray length.
            }

            right++;  // Expand the window to the right.
        }

        // Return the result. If a valid subarray is found, return the count of repetitions plus the minimum subarray length. Otherwise, return -1.
        return ans ? count + mini : -1;
    }
};


another approach using hashmap::-->
class Solution {
public:
    int minSizeSubarray(vector<int>& nums, int target)
    {
        long long int arraySum = 0;
        
        for(auto it : nums)
        {
            arraySum+=it;
        }
        
        long long int subArrayLength = 0;
        
        if(target>arraySum)
        {
            subArrayLength+= (target/arraySum)*nums.size();
            target = target%arraySum;
        }
        
        if(target==0)
        {
            return subArrayLength;
        }

        int n = nums.size();
        
        for(int i = 0;i<n;i++)
        {
            nums.push_back(nums[i]);
        }
        
        int mini = INT_MAX;
        
        unordered_map<int,int> mp;
        
        long long int currSum = 0;

        for(int i = 0;i<nums.size();i++)
        {
            currSum+=nums[i];
            
            if(currSum==target)
            {
                mini = min(mini,i+1);
            }
            
            else if(mp.find(currSum-target)!=mp.end())
            {
                mini = min(mini,i - mp[currSum-target]);
            }
            mp[currSum] = i;
        }
        
        if(mini==INT_MAX)
        {
            return -1;
        }
        return mini+subArrayLength;
        
    }
};

